import os
import re
import glob
import logging
import xml.etree.ElementTree as ET
from collections import defaultdict

logger = logging.getLogger("PolkitPro.Logic")


# Detect explicit action id checks like: action.id == "org.example.demo"
ACTION_ID_PATTERN = re.compile(r'action\.id\s*==\s*["\']([^"\']+)["\']')

class PolkitRuleFile:
    def __init__(self, path):
        self.path = path
        self.filename = os.path.basename(path)
        self.precedence = self._extract_precedence()
        self.content = ""
        self._load()

    def _extract_precedence(self):
        match = re.match(r'^(\d+)', self.filename)
        return int(match.group(1)) if match else 0

    def _load(self):
        if not os.path.exists(self.path): return
        try:
            with open(self.path, 'r', encoding='utf-8') as f:
                self.content = f.read()
        except Exception as e:
            logger.debug(f"Failed to read rule file {self.path}: {e}")
            self.content = ""

class PolkitAction:
    def __init__(self, action_id, description):
        self.action_id = action_id
        self.description = description
        self.matching_rules = []
        self.effective_rule = None
        self.overridden_rules = []
        self.annotations = {}
        self.defaults = {}
        self.origin_file = ""
        
        self.allowed_groups = []
        self.allowed_users = []
        self.allow_any = "no"

        self.external_groups = {} 
        self.external_users = {}  

    def is_managed(self):
        return len(self.allowed_groups) > 0 or len(self.allowed_users) > 0 or self.allow_any != "no"

    def is_overridden(self):
        if not self.is_managed(): return False
        return any(r.precedence > 90 for r in self.matching_rules if "90-custom" not in r.filename)

    def get_namespace(self):
        parts = self.action_id.split(".")
        return parts[-2] if len(parts) > 1 else "system"

    def update_precedence(self):
        if not self.matching_rules:
            self.effective_rule = None
            self.overridden_rules = []
            return
        self.matching_rules.sort(key=lambda r: (r.precedence, r.filename))
        self.effective_rule = self.matching_rules[-1]
        self.overridden_rules = self.matching_rules[:-1]

class RuleGenerator:
    @staticmethod
    def generate(actions):
        lines = ["/* Generated by Polkit Policy Editor */", ""]
        for aid in sorted(actions.keys()):
            action = actions[aid]
            if not action.is_managed(): continue
            lines.append(f"// [METADATA_START:{aid}]")
            lines.append(f"// GROUPS:{','.join(action.allowed_groups)}")
            lines.append(f"// USERS:{','.join(action.allowed_users)}")
            lines.append(f"// ALLOW_ANY:{action.allow_any}")
            lines.append(f'polkit.addRule(function(action, subject) {{')
            lines.append(f'    if (action.id == "{aid}") {{')
            checks = []
            if action.allowed_users:
                u_list = " || ".join([f'subject.user == "{u}"' for u in action.allowed_users])
                checks.append(f'({u_list})')
            if action.allowed_groups:
                g_list = ", ".join([f'"{g}"' for g in action.allowed_groups])
                checks.append(f'(function(){{ var gs=[{g_list}]; for(var i=0;i<gs.length;i++) if(subject.isInGroup(gs[i])) return true; return false; }}())')
            if checks:
                lines.append(f'        if ({" || ".join(checks)}) {{ return polkit.Result.YES; }}')
            if action.allow_any != "no":
                res = "YES" if action.allow_any == "yes" else "AUTH_ADMIN"
                lines.append(f'        return polkit.Result.{res};')
            lines.append(f'    }}')
            lines.append(f'    return polkit.Result.NOT_HANDLED;')
            lines.append(f'  }});')
            lines.append(f"// [METADATA_END:{aid}]\n")
        return "\n".join(lines)

class PolkitSystem:
    def __init__(self):
        self.actions = {}
        self.rule_files = []
        self.managed_path = "/etc/polkit-1/rules.d/90-custom-ui.rules"
        self.persistent_priv_path = "/etc/polkit-1/rules.d/10-polkit-editor-privilege.rules"
        self.is_dirty = False

    def refresh(self):
        print("[DEBUG] Logic: Starting system refresh...")
        self._parse_actions()
        self._parse_rules()
        self._map_rules_to_actions()
        self._load_managed_settings()
        self.is_dirty = False
        print(f"[DEBUG] Logic: Refresh complete. {len(self.actions)} actions loaded.")

    def _parse_actions(self):
        self.actions = {}
        paths = glob.glob("/usr/share/polkit-1/actions/*.policy")
        for path in paths:
            try:
                tree = ET.parse(path)
                for action in tree.getroot().findall('action'):
                    aid = action.get('id')
                    d_node = action.find('description')
                    obj = PolkitAction(aid, d_node.text if d_node is not None else "No description")
                    obj.origin_file = path
                    defs = action.find('defaults')
                    if defs is not None:
                        for c in defs: obj.defaults[c.tag] = c.text
                    for ann in action.findall('annotate'):
                        obj.annotations[ann.get('key')] = ann.text
                    self.actions[aid] = obj
            except Exception as e:
                print(f"[DEBUG] Logic: Error parsing policy {path}: {e}")

    def _parse_rules(self):
        self.rule_files = []
        for p in ["/etc/polkit-1/rules.d/*.rules", "/usr/share/polkit-1/rules.d/*.rules"]:
            found = glob.glob(p)
            print(f"[DEBUG] Logic: Searching {p}, found {len(found)} files.")
            for path in found:
                self.rule_files.append(PolkitRuleFile(path))

    def _map_rules_to_actions(self):
        rule_targets = defaultdict(set)
        rule_externals = defaultdict(lambda: {"groups": {}, "users": {}})

        for rf in self.rule_files:
            content = rf.content or ""
            matches = ACTION_ID_PATTERN.findall(content)
            if not matches:
                matches = [
                    aid for aid in self.actions.keys()
                    if re.search(rf'["\']{re.escape(aid)}["\']', content)
                ]

            for aid in matches:
                rule_targets[aid].add(rf)
                if "90-custom-ui" in rf.filename:
                    continue
                for g in re.findall(r'isInGroup\("([^"]+)"\)', content):
                    rule_externals[aid]["groups"][g] = rf.filename
                for u in re.findall(r'subject\.user\s*==\s*"([^"]+)"', content):
                    rule_externals[aid]["users"][u] = rf.filename

        for aid, action in self.actions.items():
            action.matching_rules = list(rule_targets.get(aid, []))
            action.external_groups = rule_externals.get(aid, {}).get("groups", {})
            action.external_users = rule_externals.get(aid, {}).get("users", {})
            action.update_precedence()

    def _load_managed_settings(self):
        if not os.path.exists(self.managed_path): return
        print(f"[DEBUG] Logic: Loading managed settings from {self.managed_path}")
        try:
            with open(self.managed_path, 'r', encoding='utf-8') as f:
                content = f.read()
            for aid, action in self.actions.items():
                safe_aid = re.escape(aid)
                pattern = f"// \\[METADATA_START:{safe_aid}\\](.*?)// \\[METADATA_END:{safe_aid}\\]"
                match = re.search(pattern, content, re.DOTALL)
                if match:
                    block = match.group(1)
                    g_match = re.search(r'// GROUPS:(.*)', block)
                    if g_match: action.allowed_groups = [g for g in g_match.group(1).strip().split(",") if g]
                    u_match = re.search(r'// USERS:(.*)', block)
                    if u_match: action.allowed_users = [u for u in u_match.group(1).strip().split(",") if u]
                    f_match = re.search(r'// ALLOW_ANY:(.*)', block)
                    if f_match: action.allow_any = f_match.group(1).strip()
        except Exception as e:
            print(f"[DEBUG] Logic: Error loading managed settings: {e}")
